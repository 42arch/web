---
title: Usage with TypeScript
description: React Flow is written in TypeScript! In this section we setup a basic flow with the corresponding types.
created_at: 2024-02-22
---

import { Callout } from 'nextra/components';

# Usage with TypeScript

React Flow is written in TypesScript because we value the additional safety barrier it provides.
We export all the types you need for correctly typing data structures and functions you pass to the React Flow component.
On top of that we also provide a way for you to extend the types of nodes and edges.

## Basic Usage

Let's start with the most basic types you need for a simple starting point. Typescript might already infer some of these types, but we will define them explicitly nontheless.

```tsx
import { useState, useCallback } from 'react';
import {
  ReactFlow,
  addEdge,
  applyNodeChanges,
  applyEdgeChanges,
  type Node,
  type Edge,
  type FitViewOptions,
  type onNodesChange,
  type onEdgesChange,
  type onNodeDrag,
  type Connection,
  type NodeTypes,
  type EdgeTypes,
} from '@xyflow/react';

import CustomNodeFoo from './CustomNodeFoo';
import CustomNodeBar from './CustomNodeBar';

import CustomEdgeBaz from './CustomEdgeBaz';
import CustomEdgeQux from './CustomEdgeQux';

const initialNodes: Node[] = [
  { id: '1', data: { label: 'Node 1' }, position: { x: 5, y: 5 } },
  { id: '2', data: { label: 'Node 2' }, position: { x: 5, y: 100 } },
];

const initialEdges: Edge[] = [{ id: 'e1-2', source: '1', target: '2' }];

const fitViewOptions: FitViewOptions = {
  padding: 0.2,
};

const defaultEdgeOptions: DefaultEdgeOptions = {
  animated: true,
};

const nodeTypes: NodeTypes = {
  foo: CustomNodeFoo,
  bar: CustomNodeBar,
};

const edgeTypes: EdgeTypes = {
  baz: CustomEdgeBaz,
  qux: CustomEdgeQux,
};

const onNodeDrag: OnNodeDrag = (_, node) => {
  console.log('drag event', node.data);
};

function Flow() {
  const [nodes, setNodes] = useState<Node[]>(initialNodes);
  const [edges, setEdges] = useState<Edge[]>(initialEdges);

  const onNodesChange: OnNodesChange = useCallback(
    (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),
    [setNodes],
  );
  const onEdgesChange: OnEdgesChange = useCallback(
    (changes) => setEdges((eds) => applyEdgeChanges(changes, eds)),
    [setEdges],
  );
  const onConnect: OnConnect = useCallback(
    (connection) => setEdges((eds) => addEdge(connection, eds)),
    [setEdges],
  );

  return (
    <ReactFlow
      nodes={nodes}
      nodeTypes={nodeTypes}
      edges={edges}
      edgeTypes={edgeTypes}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
      onConnect={onConnect}
      onNodeDrag={onNodeDrag}
      fitView
      fitViewOptions={fitViewOptions}
      defaultEdgeOptions={defaultEdgeOptions}
    />
  );
}
```

### Custom Nodes

When working with [custom nodes](/learn/customization/custom-nodes) you have the possibility to attach custom data to every node.
The type of the data is expressed by a generic passed to the `Node` type.

```tsx filename="CustomNodeFoo.tsx"
import type { NodeProps } from '@xyflow/react';

type FooNodeData = {
  mySpecialNumber: number;
};

export default function CustomNodeFoo({ data }: NodeProps<FooNodeData>) {
  return <div>A special number: {data.mySpecialNumber}</div>;
}
```

### Custom Edges

For [custom edges](/learn/customization/custom-nodes) you have the same possiblity as for custom nodes.
The type of the data is expressed by a generic passed to the `Edge` type.

```tsx filename="CustomEdgeBaz.tsx"
import { getStraightPath, BaseEdge, type EdgeProps } from '@xyflow/react';

type BazEdgeData = {
  value: number;
};

function CustomEdgeBaz({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
}: EdgeProps<BazEdgeData>) {
  const [edgePath] = getStraightPath({ sourceX, sourceY, targetX, targetY });

  return <BaseEdge id={id} path={edgePath} />;
}

export default CustomEdgeBaz;
```

## Advanced Usage

When creating a more complex application with React Flow, you will end up with a number of custom nodes & edges, each with different kinds of data attached to them.
Anytime we operate on these nodes & edges through built in functions and hooks, we have to make sure that we [narrow down](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
the types of nodes & edges to prevent runtime errors.

### NodeType, EdgeType unions

You will stumble upon many functions, callbacks and hooks (even the ReactFlow component itself) that expect a `NodeType` or `EdgeType` generic. These generics are simply
[Unions](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types) of all the different types of nodes & edges you have in your application.
As long as you have typed the data objects correctly (see previous section), you can use their exported type.

<Callout type="info">
  If you use the any of the built-in nodes ('input', 'output', 'default') or
  edges ('straight', 'step', 'smoothstep', 'bezier'), you can add the
  `BuiltInNode` and `BuiltInEdge` types exported from `@xyflow/react` to your
  union type.
</Callout>

```tsx
import type { BuiltInNode, BuiltInEdge } from '@xyflow/react';
// Custom Nodes
import CustomNodeFoo from './CustomNodeFoo';
import CustomNodeBar from './CustomNodeBar';
// Custom Edges
import CustomEdgeBaz from './CustomEdgeBaz';
import CustomEdgeQux from './CustomEdgeQux';

export type CustomNodeType = BuiltInNode | CustomNodeFoo | CustomNodeBar;
export type CustomEdgeType = BuiltInEdge | CustomEdgeBaz | CustomEdgeQux;
```

### &lt;ReactFlow />

To receive correct types for callback functions, you can pass your union types to the `ReactFlow` component.
By doing that you will have to type your callback functions explicitly.

```tsx
import { type OnNodeDrag } from '@xyflow/react';

  // ...

  // Pass your union type here ...
  const onNodeDrag: OnNodeDrag<CustomNodeType> = (_, node) => {
    if (node.type === 'foo') {
      // From here on, Typescript knows that node.data
      // is of type { mySpecialNumber: number }
      console.log('drag event', node.data.mySpecialNumber);
    }
  };

  return (
    <ReactFlow<CustomNodeType, CustomEdgeType> // ... and here ...
      nodes={nodes}
      nodeTypes={nodeTypes}
      edges={edges}
      edgeTypes={edgeTypes}
      onNodeDrag={onNodeDrag} // .. so these types match
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
      onConnect={onConnect}
      defaultEdgeOptions={defaultEdgeOptions}
      fitViewOptions={fitViewOptions}
      fitView
    />
  );
}
```

### Hooks & Functions

Our type unions can be used to type the return values of many hooks.

```tsx filename="CustomNodeBar.tsx"
import { useHandleConnections, useNodesData, useStore } from '@xyflow/react';

export default function CustomNodeBar() {
  // You can type useStore by typing the selector function
  const nodes = useStore((s: ReactFlowState<CustomNodeType>) => ({
    nodes: s.nodes,
  }));

  const connections = useHandleConnections({
    type: 'target',
  });

  const nodesData = useNodesData<CustomNodeType>(
    connections.map((connection) => connection.source),
  );

  nodeData.forEach(({ type, data }) => {
    if (type === 'foo') {
      // This is type safe because we have narrowed down the type
      console.log(data.mySpecialNumber);
    }
  });
  // ...
}
```

### Type guards

There are multiple ways you can define [type guards](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#typeof-type-guards) in Typescript.
One way is to define type guard functions like `isFooNode` or `isBarNode` to filter out specific nodes from a list of nodes.

```tsx
function isFooNode(node: CustomNodeType): node is CustomNodeFoo {
  return node.type === 'foo';
}

// fooNodes is of type CustomNodeFoo[]
let fooNodes = nodes.filter(isFooNode);
```
