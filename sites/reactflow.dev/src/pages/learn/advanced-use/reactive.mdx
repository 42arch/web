---
title: Computing Flows
description: Learn how to extend React Flow to compute data going through flowgraphs.
created_at: 2024-02-14
---

# Computing Flows

import { Callout } from 'nextra/components';

<Callout type="info">
  For this guide we assume that you already know about the [core
  concepts](/learn/concepts/core-concepts) of React Flow and how to implement
  [custom nodes](/learn/customization/custom-nodes).
</Callout>

React Flow is first and foremost a visualization library. What happens with the data that is being visualized is very much up to you. Do you want to store it in a database? Do you want to send it to a server? Do you want to synchronize realtime information with a robot? That's your call and we won't stand in you way.

Sometimes however, you might want to copmute data flows right in React Flow: Changing UI based on the data being connected or maybe you even want to implement a simple tool that runs fully inside your browser. In those cases: This is the guide for you.

## What are we going to build?

At the end of this guide you will have a interactive flowgraph that makes a color out of three seperate number input field and determines wether a white or black text would be more readable on that background color.

<ExampleViewer
  activeFile="Log.js"
  codePath="api-flows/Reactive9"
  applyStyles={false}
  editorHeight={500}
  showEditor={false}
  options={{
    editorHeight: 500,
    editorWidthPercentage: 45,
    wrapContent: true,
  }}
  additionalFiles={[
    'NumberInput.js',
    'ColorPreview.js',
    'Lightness.js',
    'Log.js',
  ]}
/>

## Creating some Custom Nodes

Let's start by creating a custom input node and add 3 instances of it to the flow. We will be using a controlled html `<input type="number" />` and limit it to integer numbers between 0-255 inside the `onChange` event handler - and yes, you guessed it: this tutorial is going to be about colors.

import ExampleViewer from '@/components/example-viewer';

<ExampleViewer
  activeFile="NumberInput.js"
  codePath="api-flows/Reactive1"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js']}
  editorHeight={500}
/>

Next, we'll add a new custom node with one target handle for each color channel and a background that displays the resulting color. Now that we have multiple handles of the same kind on a single node, don't forget to give each one a seperate id! Let's also add edges going from the input nodes to the color node while we are at it.

<ExampleViewer
  activeFile="ColorPreview.js"
  codePath="api-flows/Reactive2"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js', 'ColorPreview.js']}
  editorHeight={500}
/>

## Piping the data

So how do we go about actually getting the data from the input nodes to the color node? This is a simple 2 step process that involves 2 hooks created for exactly this purpose:

1. Make the value of the number inputs accessible by storing them inside the node `data` object by using [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data).
2. [`useHandleConnections`](/api-reference/hooks/use-handle-connections) for finding out which nodes are connected & [`useNodesData` ](/api-reference/hooks/use-nodes-data) for getting the data from the connected nodes.

### Step 1: Writing values to the data object

First we add some initial values for the input nodes inside the `data` object in our `initialNodes` array and use them as initial state inside the input nodes.
Then we import the function [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data). from the [`useReactFlow`](/api-reference/hooks/use-react-flow) hook and use it to update the `data` object of the node with a new value whenever the input changes.

<Callout type="info">
By default, the data you pass to [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data). will be merged with the old data object. You can pass `{ replace: true }` as an option to replace the object instead.
</Callout>

<ExampleViewer
  activeFile="NumberInput.js"
  codePath="api-flows/Reactive3"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js', 'ColorPreview.js']}
  editorHeight={500}
/>

<Callout type="warning">
  When dealing with input fields you don't want to use a nodes `data` object as
  ui state directly. There is a delay in updating the data object and the cursor
  might jump around erraticly and lead to unwanted inputs.
</Callout>

### Step 2: Getting data from connected nodes

We start by determining all connections for each handle with the [`useHandleConnections`](/api-reference/hooks/use-handle-connections) hook and then fetching the data for the first connected node with the [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data) hook.
Now we can react to changes of the input nodes and update the background color accordingly with a `useEffect` hook.

<Callout type="info">
  Note that each handle can have multiple nodes connected to it and you might
  want to restrict the number of connections to a single handle inside your
  application. See [this example](/examples/nodes/connection-limit) on how to do
  that.
</Callout>

<b>And there you go!</b> Try changing the input values and see the color changing
in real time.

<ExampleViewer
  activeFile="ColorPreview.js"
  codePath="api-flows/Reactive4"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js', 'ColorPreview.js']}
  editorHeight={500}
/>

### Improving the code

It might seem awkward to get the connections first, then the data seperately for each handle. In nodes like these with multiple handles you should consider creating a handle component that isolates connection states and node data binding. We can do this pretty easily by creating a small inline component.

<ExampleViewer
  activeFile="ColorPreview.js"
  codePath="api-flows/Reactive5"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js', 'ColorPreview.js']}
  editorHeight={500}
/>

## Getting more complex

Allright, we have a simple example of how to pipe data through React Flow. But what if we want to do something more complex? What if we want to transform the data along the way? Or even take different paths? No problem! We can do that too.

### Continuing the flow

Let's make our flow longer! We begin just like before by writing the accumulated `{r, g, b}` values to the nodes `data` object and adding an output handle to the color node.

<Callout type="info">
  Because there are no inputs fields on this node, we don't need to keep a local
  state. Let's just read and update the nodes `data` object directly.
</Callout>

<ExampleViewer
  activeFile="ColorPreview.js"
  codePath="api-flows/Reactive6"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js', 'ColorPreview.js']}
  editorHeight={500}
/>

Next, we add a new node that takes in a color object and determines if it is either a light or a dark color. We cam use the [relative luminance formula](https://en.wikipedia.org/wiki/Relative_luminance#Relative_luminance_and_%22gamma_encoded%22_colorspaces)
`luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b`
to calculate the perceived brightness of a color (0 being the darkest and 255 being the brightest) and 128 being the middle we can assume everything >= 128 being a light color.

<ExampleViewer
  activeFile="Lightness.js"
  codePath="api-flows/Reactive7"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js', 'ColorPreview.js', 'Lightness.js']}
  editorHeight={500}
/>

### Conditional Branching

What if we would like to take a different path in our flow based on the perceived lightness? Let's give our Lightness node two source handles `light` and `dark` and seperate the node `data` object by source handle IDs. This is needed if you have multiple source handles to distinguish between each source handles data.

But what does it mean to 'take a different route'? One solution would be to assume that `null` or `undefined` data hooked up to a target handle is considered a 'stop'. In our case we can simply write the incoming color into `data.values.light` if it's a light color and into `data.values.dark` if it's a dark color and set the respective other value to `null`.

<ExampleViewer
  activeFile="Lightness.js"
  codePath="api-flows/Reactive8"
  applyStyles={false}
  editorHeight={500}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js', 'ColorPreview.js', 'Lightness.js']}
/>

Cool! Now we only need a last node so we see if it actually works... We can create a simple Log node that just displays the hooked up data and BAM! We are done!

<ExampleViewer
  activeFile="Log.js"
  codePath="api-flows/Reactive9"
  applyStyles={false}
  editorHeight={500}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={[
    'NumberInput.js',
    'ColorPreview.js',
    'Lightness.js',
    'Log.js',
  ]}
/>
