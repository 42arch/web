---
title: Computing Flows
description: Learn how to extend React Flow to compute data going through flow graphs.
created_at: 2024-02-14
---

# Computing Flows

import { Callout } from 'nextra/components';

<Callout type="info">
  For this guide we assume that you already know about the [core
  concepts](/learn/concepts/core-concepts) of React Flow and how to implement
  [custom nodes](/learn/customization/custom-nodes).
</Callout>

React Flow is first and foremost a UI library for rendering so called node-based applications. What happens with the data that is being rendered is very much up to you. Do you want to store it in a database? Do you want to send it to a server? Do you want to synchronize realtime information with a robot? That's your call and we won't stand in you way.

Sometimes however, you might want to compute data flows right in React Flow: update a node based on the connected data or maybe you even want to implement a tool that runs fully inside your browser. In those cases, this is the guide for you.

## What are we going to build?

At the end of this guide you will have an interactive flow graph that generates a color out of three separate number input fields (red, green and blue) and determines whether a white or black text would be more readable on that background color.

<ExampleViewer
  codePath="api-flows/Reactive9"
  editorHeight={500}
  applyStyles={false}
  showEditor={false}
  options={{
    editorHeight: 500,
  }}
  additionalFiles={[
    'NumberInput.js',
    'ColorPreview.js',
    'Lightness.js',
    'Log.js',
  ]}
/>

## Creating custom nodes

Let's start by creating a custom input node (`NumberInput.js`) and add three instances of it. We will be using a controlled `<input type="number" />` and limit it to integer numbers between 0 - 255 inside the `onChange` event handler - and yes, you guessed it: this tutorial is going to be about colors.

import ExampleViewer from '@/components/example-viewer';

<ExampleViewer
  activeFile="NumberInput.js"
  codePath="api-flows/Reactive1"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js']}
  editorHeight={500}
/>

Next, we'll add a new custom node (`ColorPreview.js`) with one target handle for each color channel and a background that displays the resulting color.

<Callout type="info">
  Whenever you have multiple handles of the same kind on a single node, don't
  forget to give each one a seperate id!
</Callout>
Let's also add edges going from the input nodes to the color node to our `initialEdges`
array while we are at it.

<ExampleViewer
  activeFile="ColorPreview.js"
  codePath="api-flows/Reactive2"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js', 'ColorPreview.js']}
  editorHeight={500}
/>

## Piping data

So how do we actually get the data from the input nodes to the color node? This is a two step process that involves two hooks created for exactly this purpose:

1. Store each number input value inside the node's `data` object with help of [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data) callback.
2. Find out which nodes are connected by using [`useHandleConnections`](/api-reference/hooks/use-handle-connections) and then use [`useNodesData`](/api-reference/hooks/use-nodes-data) for receiving the data from the connected nodes.

### Step 1: Writing values to the data object

First we add some initial values for the input nodes inside the `data` object in our `initialNodes` array and use them as initial state for the input nodes.
Then we grab the function [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data) from the [`useReactFlow`](/api-reference/hooks/use-react-flow) hook and use it to update the `data` object of the node with a new value whenever the input changes.

<Callout type="info">
By default, the data you pass to [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data) will be merged with the old data object. This makes it easier to do partial updates and saves you in case you forget to add `{...data}`. You can pass `{ replace: true }` as an option to replace the object instead.
</Callout>

<ExampleViewer
  activeFile="NumberInput.js"
  codePath="api-flows/Reactive3"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js', 'ColorPreview.js']}
  editorHeight={500}
/>

<Callout type="warning">
  <b>
    When dealing with input fields you don't want to use a nodes `data` object
    as UI state directly.
  </b>
  There is a delay in updating the data object and the cursor might jump around erraticly
  and lead to unwanted inputs.
</Callout>

### Step 2: Getting data from connected nodes

We start by determining all connections for each handle with the [`useHandleConnections`](/api-reference/hooks/use-handle-connections) hook and then fetching the data for the first connected node with [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data).

<Callout type="info">
  Note that each handle can have multiple nodes connected to it and you might
  want to restrict the number of connections to a single handle inside your
  application. Check out the [connection limit
  example](/examples/nodes/connection-limit) on how to do that.
</Callout>

<b>And there you go!</b> Try changing the input values and see the color changing
in real time.

<ExampleViewer
  activeFile="ColorPreview.js"
  codePath="api-flows/Reactive4"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js', 'ColorPreview.js']}
  editorHeight={500}
/>

### Improving the code

It might seem awkward to get the connections first, then the data seperately for each handle. In nodes like these with multiple handles you should consider creating a custom handle component that isolates connection states and node data binding. We can do this by creating a new component for the custom handle and promoting color to local state.

<ExampleViewer
  activeFile="ColorPreview.js"
  codePath="api-flows/Reactive5"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js', 'ColorPreview.js']}
  editorHeight={500}
/>

## Getting more complex

Alright, we have a simple example of how to pipe data through React Flow. But what if we want to do something more complex? What if we want to transform the data along the way? Or even take different paths? No problem! We can do that too.

### Continuing the flow

Let's extend our flow! Start by adding an output `<Handle type="source" position={Position.Right} />` to the color node.

<Callout type="info">
  Because there are no inputs fields on this node, we don't need to keep a local
  state at all. We can just read and update the nodes `data` object directly.
</Callout>

Next, we add a new node (`Lightness.js`) that takes in a color object and determines if it is either a light or a dark color. We can use the [relative luminance formula](https://en.wikipedia.org/wiki/Relative_luminance#Relative_luminance_and_%22gamma_encoded%22_colorspaces)
`luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b`
to calculate the perceived brightness of a color (0 being the darkest and 255 being the brightest) and 128 being the middle we can assume everything >= 128 being a light color.

<ExampleViewer
  activeFile="Lightness.js"
  codePath="api-flows/Reactive7"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js', 'ColorPreview.js', 'Lightness.js']}
  editorHeight={500}
/>

### Conditional branching

What if we would like to take a different path in our flow based on the perceived lightness? Let's give our lightness node two source handles `light` and `dark` and separate the node `data` object by source handle IDs. This is needed if you have multiple source handles to distinguish between each source handles data.

But what does it mean to "take a different route"? One solution would be to assume that `null` or `undefined` data hooked up to a target handle is considered a "stop". In our case we can write the incoming color into `data.values.light` if it's a light color and into `data.values.dark` if it's a dark color and set the respective other value to `null`.

<ExampleViewer
  activeFile="Lightness.js"
  codePath="api-flows/Reactive8"
  applyStyles={false}
  editorHeight={500}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js', 'ColorPreview.js', 'Lightness.js']}
/>

Cool! Now we only need a last node to see if it actually works... We can create a custom debugging node (`Log.js`) that displays the hooked up data and BAM! We are done!

<ExampleViewer
  activeFile="Log.js"
  codePath="api-flows/Reactive9"
  applyStyles={false}
  editorHeight={500}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={[
    'NumberInput.js',
    'ColorPreview.js',
    'Lightness.js',
    'Log.js',
  ]}
/>

### Summary

You have learned how to actually move data through the flow and transform it along the way.
All you need to do is

1. store data inside the node's `data` object with help of [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data) callback.
2. find out which nodes are connected by using [`useHandleConnections`](/api-reference/hooks/use-handle-connections) and then use [`useNodesData`](/api-reference/hooks/use-nodes-data) for receiving the data from the connected nodes.

You can implement branching for example by interpreting incoming data that is undefined as a "stop". As a side note, most flowgraphs that also have a branching usually seperate the triggering of nodes from the actual data hooked up to the nodes. Unreal Engines Blueprints are a good example for this.

<Callout type="info">
  A last note before you go: you should find a consistent way of structuring all
  your node data, instead of mixing ideas like we did just now. This means for
  example, if you start working with splitting data by handle ID you should do
  it for all nodes, regardless whether they have multiple handles or not. Being
  able to make assumptions about the structure of your data throughout you flow
  will make your life a lot easier.
</Callout>
